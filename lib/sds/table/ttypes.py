# encoding: utf-8
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import sds.errors.ttypes
import sds.common.ttypes
import sds.auth.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class DataType(object):
  """
  数据类型
  """
  BOOL = 1
  INT8 = 2
  INT16 = 3
  INT32 = 4
  INT64 = 5
  FLOAT = 6
  DOUBLE = 7
  STRING = 8
  BINARY = 9
  RAWBINARY = 10
  BOOL_SET = 100
  INT8_SET = 101
  INT16_SET = 102
  INT32_SET = 103
  INT64_SET = 104
  FLOAT_SET = 105
  DOUBLE_SET = 106
  STRING_SET = 107
  BINARY_SET = 108

  _VALUES_TO_NAMES = {
    1: "BOOL",
    2: "INT8",
    3: "INT16",
    4: "INT32",
    5: "INT64",
    6: "FLOAT",
    7: "DOUBLE",
    8: "STRING",
    9: "BINARY",
    10: "RAWBINARY",
    100: "BOOL_SET",
    101: "INT8_SET",
    102: "INT16_SET",
    103: "INT32_SET",
    104: "INT64_SET",
    105: "FLOAT_SET",
    106: "DOUBLE_SET",
    107: "STRING_SET",
    108: "BINARY_SET",
  }

  _NAMES_TO_VALUES = {
    "BOOL": 1,
    "INT8": 2,
    "INT16": 3,
    "INT32": 4,
    "INT64": 5,
    "FLOAT": 6,
    "DOUBLE": 7,
    "STRING": 8,
    "BINARY": 9,
    "RAWBINARY": 10,
    "BOOL_SET": 100,
    "INT8_SET": 101,
    "INT16_SET": 102,
    "INT32_SET": 103,
    "INT64_SET": 104,
    "FLOAT_SET": 105,
    "DOUBLE_SET": 106,
    "STRING_SET": 107,
    "BINARY_SET": 108,
  }

class OperatorType(object):
  """
  操作符类型
  """
  EQUAL = 1
  NOT_EQUAL = 2
  GREATER = 3
  GREATER_OR_EQUAL = 4
  LESS = 5
  LESS_OR_EQUAL = 6

  _VALUES_TO_NAMES = {
    1: "EQUAL",
    2: "NOT_EQUAL",
    3: "GREATER",
    4: "GREATER_OR_EQUAL",
    5: "LESS",
    6: "LESS_OR_EQUAL",
  }

  _NAMES_TO_VALUES = {
    "EQUAL": 1,
    "NOT_EQUAL": 2,
    "GREATER": 3,
    "GREATER_OR_EQUAL": 4,
    "LESS": 5,
    "LESS_OR_EQUAL": 6,
  }

class SecondaryIndexConsistencyMode(object):
  """
  索引数据一致性类型
  """
  LAZY = 0
  EAGER = 1
  IMMUTABLE = 2

  _VALUES_TO_NAMES = {
    0: "LAZY",
    1: "EAGER",
    2: "IMMUTABLE",
  }

  _NAMES_TO_VALUES = {
    "LAZY": 0,
    "EAGER": 1,
    "IMMUTABLE": 2,
  }

class CannedAcl(object):
  """
  ACL模板，针对每个应用进行设置，
  开发者登录可以访问所拥有的表数据，无需额外设置
  """
  APP_SECRET_READ = 1
  APP_SECRET_WRITE = 2
  APP_USER_ENTITY_GROUP_READ = 3
  APP_USER_ENTITY_GROUP_WRITE = 4
  APP_USER_READ = 5
  APP_USER_WRITE = 6
  PUBLIC_READ = 7
  PUBLIC_WRITE = 8

  _VALUES_TO_NAMES = {
    1: "APP_SECRET_READ",
    2: "APP_SECRET_WRITE",
    3: "APP_USER_ENTITY_GROUP_READ",
    4: "APP_USER_ENTITY_GROUP_WRITE",
    5: "APP_USER_READ",
    6: "APP_USER_WRITE",
    7: "PUBLIC_READ",
    8: "PUBLIC_WRITE",
  }

  _NAMES_TO_VALUES = {
    "APP_SECRET_READ": 1,
    "APP_SECRET_WRITE": 2,
    "APP_USER_ENTITY_GROUP_READ": 3,
    "APP_USER_ENTITY_GROUP_WRITE": 4,
    "APP_USER_READ": 5,
    "APP_USER_WRITE": 6,
    "PUBLIC_READ": 7,
    "PUBLIC_WRITE": 8,
  }

class TableState(object):
  """
  表状态
  """
  CREATING = 1
  ENABLING = 2
  ENABLED = 3
  DISABLING = 4
  DISABLED = 5
  DELETING = 6
  DELETED = 7
  LAZY_DELETING = 8
  LAZY_DELETE = 9
  RESTORING = 10

  _VALUES_TO_NAMES = {
    1: "CREATING",
    2: "ENABLING",
    3: "ENABLED",
    4: "DISABLING",
    5: "DISABLED",
    6: "DELETING",
    7: "DELETED",
    8: "LAZY_DELETING",
    9: "LAZY_DELETE",
    10: "RESTORING",
  }

  _NAMES_TO_VALUES = {
    "CREATING": 1,
    "ENABLING": 2,
    "ENABLED": 3,
    "DISABLING": 4,
    "DISABLED": 5,
    "DELETING": 6,
    "DELETED": 7,
    "LAZY_DELETING": 8,
    "LAZY_DELETE": 9,
    "RESTORING": 10,
  }

class ScanOp(object):
  COUNT = 0
  DELETE = 1
  UPDATE = 2

  _VALUES_TO_NAMES = {
    0: "COUNT",
    1: "DELETE",
    2: "UPDATE",
  }

  _NAMES_TO_VALUES = {
    "COUNT": 0,
    "DELETE": 1,
    "UPDATE": 2,
  }

class BatchOp(object):
  GET = 1
  PUT = 2
  INCREMENT = 3
  REMOVE = 4

  _VALUES_TO_NAMES = {
    1: "GET",
    2: "PUT",
    3: "INCREMENT",
    4: "REMOVE",
  }

  _NAMES_TO_VALUES = {
    "GET": 1,
    "PUT": 2,
    "INCREMENT": 3,
    "REMOVE": 4,
  }


class Value(object):
  """
  数据值union类型

  Attributes:
   - boolValue
   - int8Value
   - int16Value
   - int32Value
   - int64Value
   - doubleValue: 用于FLOAT/DOUBLE类型
   - stringValue
   - binaryValue: 用于BINARY/RAWBINARY类型
   - boolSetValue
   - int8SetValue
   - int16SetValue
   - int32SetValue
   - int64SetValue
   - doubleSetValue: 用于FLOAT/DOUBLE类型集合
   - stringSetValue
   - binarySetValue
   - nullValue: null，只用于RC_BASIC存储格式
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'boolValue', None, None, ), # 1
    (2, TType.BYTE, 'int8Value', None, None, ), # 2
    (3, TType.I16, 'int16Value', None, None, ), # 3
    (4, TType.I32, 'int32Value', None, None, ), # 4
    (5, TType.I64, 'int64Value', None, None, ), # 5
    (6, TType.DOUBLE, 'doubleValue', None, None, ), # 6
    (7, TType.STRING, 'stringValue', None, None, ), # 7
    (8, TType.STRING, 'binaryValue', None, None, ), # 8
    (9, TType.LIST, 'boolSetValue', (TType.BOOL,None), None, ), # 9
    (10, TType.LIST, 'int8SetValue', (TType.BYTE,None), None, ), # 10
    (11, TType.LIST, 'int16SetValue', (TType.I16,None), None, ), # 11
    (12, TType.LIST, 'int32SetValue', (TType.I32,None), None, ), # 12
    (13, TType.LIST, 'int64SetValue', (TType.I64,None), None, ), # 13
    (14, TType.LIST, 'doubleSetValue', (TType.DOUBLE,None), None, ), # 14
    (15, TType.LIST, 'stringSetValue', (TType.STRING,None), None, ), # 15
    (16, TType.LIST, 'binarySetValue', (TType.STRING,None), None, ), # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.BOOL, 'nullValue', None, None, ), # 20
  )

  def __init__(self, boolValue=None, int8Value=None, int16Value=None, int32Value=None, int64Value=None, doubleValue=None, stringValue=None, binaryValue=None, boolSetValue=None, int8SetValue=None, int16SetValue=None, int32SetValue=None, int64SetValue=None, doubleSetValue=None, stringSetValue=None, binarySetValue=None, nullValue=None,):
    self.boolValue = boolValue
    self.int8Value = int8Value
    self.int16Value = int16Value
    self.int32Value = int32Value
    self.int64Value = int64Value
    self.doubleValue = doubleValue
    self.stringValue = stringValue
    self.binaryValue = binaryValue
    self.boolSetValue = boolSetValue
    self.int8SetValue = int8SetValue
    self.int16SetValue = int16SetValue
    self.int32SetValue = int32SetValue
    self.int64SetValue = int64SetValue
    self.doubleSetValue = doubleSetValue
    self.stringSetValue = stringSetValue
    self.binarySetValue = binarySetValue
    self.nullValue = nullValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.boolValue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.int8Value = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.int16Value = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int32Value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.int64Value = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.doubleValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binaryValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.boolSetValue = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readBool();
            self.boolSetValue.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.int8SetValue = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readByte();
            self.int8SetValue.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.int16SetValue = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readI16();
            self.int16SetValue.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.int32SetValue = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = iprot.readI32();
            self.int32SetValue.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.int64SetValue = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = iprot.readI64();
            self.int64SetValue.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.doubleSetValue = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readDouble();
            self.doubleSetValue.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.stringSetValue = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readString();
            self.stringSetValue.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.binarySetValue = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.binarySetValue.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BOOL:
          self.nullValue = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Value')
    if self.boolValue is not None:
      oprot.writeFieldBegin('boolValue', TType.BOOL, 1)
      oprot.writeBool(self.boolValue)
      oprot.writeFieldEnd()
    if self.int8Value is not None:
      oprot.writeFieldBegin('int8Value', TType.BYTE, 2)
      oprot.writeByte(self.int8Value)
      oprot.writeFieldEnd()
    if self.int16Value is not None:
      oprot.writeFieldBegin('int16Value', TType.I16, 3)
      oprot.writeI16(self.int16Value)
      oprot.writeFieldEnd()
    if self.int32Value is not None:
      oprot.writeFieldBegin('int32Value', TType.I32, 4)
      oprot.writeI32(self.int32Value)
      oprot.writeFieldEnd()
    if self.int64Value is not None:
      oprot.writeFieldBegin('int64Value', TType.I64, 5)
      oprot.writeI64(self.int64Value)
      oprot.writeFieldEnd()
    if self.doubleValue is not None:
      oprot.writeFieldBegin('doubleValue', TType.DOUBLE, 6)
      oprot.writeDouble(self.doubleValue)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 7)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.binaryValue is not None:
      oprot.writeFieldBegin('binaryValue', TType.STRING, 8)
      oprot.writeString(self.binaryValue)
      oprot.writeFieldEnd()
    if self.boolSetValue is not None:
      oprot.writeFieldBegin('boolSetValue', TType.LIST, 9)
      oprot.writeListBegin(TType.BOOL, len(self.boolSetValue))
      for iter48 in self.boolSetValue:
        oprot.writeBool(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int8SetValue is not None:
      oprot.writeFieldBegin('int8SetValue', TType.LIST, 10)
      oprot.writeListBegin(TType.BYTE, len(self.int8SetValue))
      for iter49 in self.int8SetValue:
        oprot.writeByte(iter49)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int16SetValue is not None:
      oprot.writeFieldBegin('int16SetValue', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.int16SetValue))
      for iter50 in self.int16SetValue:
        oprot.writeI16(iter50)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int32SetValue is not None:
      oprot.writeFieldBegin('int32SetValue', TType.LIST, 12)
      oprot.writeListBegin(TType.I32, len(self.int32SetValue))
      for iter51 in self.int32SetValue:
        oprot.writeI32(iter51)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int64SetValue is not None:
      oprot.writeFieldBegin('int64SetValue', TType.LIST, 13)
      oprot.writeListBegin(TType.I64, len(self.int64SetValue))
      for iter52 in self.int64SetValue:
        oprot.writeI64(iter52)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.doubleSetValue is not None:
      oprot.writeFieldBegin('doubleSetValue', TType.LIST, 14)
      oprot.writeListBegin(TType.DOUBLE, len(self.doubleSetValue))
      for iter53 in self.doubleSetValue:
        oprot.writeDouble(iter53)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stringSetValue is not None:
      oprot.writeFieldBegin('stringSetValue', TType.LIST, 15)
      oprot.writeListBegin(TType.STRING, len(self.stringSetValue))
      for iter54 in self.stringSetValue:
        oprot.writeString(iter54)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.binarySetValue is not None:
      oprot.writeFieldBegin('binarySetValue', TType.LIST, 16)
      oprot.writeListBegin(TType.STRING, len(self.binarySetValue))
      for iter55 in self.binarySetValue:
        oprot.writeString(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullValue is not None:
      oprot.writeFieldBegin('nullValue', TType.BOOL, 20)
      oprot.writeBool(self.nullValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Datum(object):
  """
  数据单元

  Attributes:
   - type
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'value', (Value, Value.thrift_spec), None, ), # 2
  )

  def __init__(self, type=None, value=None,):
    self.type = type
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = Value()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Datum')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvisionThroughput(object):
  """
  吞吐量配额

  Attributes:
   - readCapacity
   - writeCapacity
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'readCapacity', None, None, ), # 1
    (2, TType.I64, 'writeCapacity', None, None, ), # 2
  )

  def __init__(self, readCapacity=None, writeCapacity=None,):
    self.readCapacity = readCapacity
    self.writeCapacity = writeCapacity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.readCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.writeCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvisionThroughput')
    if self.readCapacity is not None:
      oprot.writeFieldBegin('readCapacity', TType.I64, 1)
      oprot.writeI64(self.readCapacity)
      oprot.writeFieldEnd()
    if self.writeCapacity is not None:
      oprot.writeFieldBegin('writeCapacity', TType.I64, 2)
      oprot.writeI64(self.writeCapacity)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableQuota(object):
  """
  空间配额

  Attributes:
   - size: 空间配额，单位为字节
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'size', None, None, ), # 1
  )

  def __init__(self, size=None,):
    self.size = size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.size = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableQuota')
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 1)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeySpec(object):
  """
  Attributes:
   - attribute
   - asc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'attribute', None, None, ), # 1
    (2, TType.BOOL, 'asc', None, True, ), # 2
  )

  def __init__(self, attribute=None, asc=thrift_spec[2][4],):
    self.attribute = attribute
    self.asc = asc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.attribute = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.asc = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeySpec')
    if self.attribute is not None:
      oprot.writeFieldBegin('attribute', TType.STRING, 1)
      oprot.writeString(self.attribute)
      oprot.writeFieldEnd()
    if self.asc is not None:
      oprot.writeFieldBegin('asc', TType.BOOL, 2)
      oprot.writeBool(self.asc)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LocalSecondaryIndexSpec(object):
  """
  局部二级索引定义

  Attributes:
   - indexSchema: 索引定义
   - projections: 映射的属性，仅当索引类型为Eager时才可设置
   - consistencyMode: 索引数据一致性模式
   - unique: 是否为唯一索引
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'indexSchema', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'projections', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'consistencyMode', None,     0, ), # 3
    (4, TType.BOOL, 'unique', None, False, ), # 4
  )

  def __init__(self, indexSchema=None, projections=None, consistencyMode=thrift_spec[3][4], unique=thrift_spec[4][4],):
    self.indexSchema = indexSchema
    self.projections = projections
    self.consistencyMode = consistencyMode
    self.unique = unique

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.indexSchema = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = KeySpec()
            _elem61.read(iprot)
            self.indexSchema.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.projections = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString();
            self.projections.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.consistencyMode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.unique = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LocalSecondaryIndexSpec')
    if self.indexSchema is not None:
      oprot.writeFieldBegin('indexSchema', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.indexSchema))
      for iter68 in self.indexSchema:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.projections is not None:
      oprot.writeFieldBegin('projections', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.projections))
      for iter69 in self.projections:
        oprot.writeString(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.consistencyMode is not None:
      oprot.writeFieldBegin('consistencyMode', TType.I32, 3)
      oprot.writeI32(self.consistencyMode)
      oprot.writeFieldEnd()
    if self.unique is not None:
      oprot.writeFieldBegin('unique', TType.BOOL, 4)
      oprot.writeBool(self.unique)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EntityGroupSpec(object):
  """
  EntityGroup定义

  Attributes:
   - attributes: 属性有序列表
   - enableHash: 是否对属性进行哈希分布:
  开启后表中记录按照(hash(attribute value), attribute value)大小顺序分布
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'attributes', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'enableHash', None, True, ), # 2
  )

  def __init__(self, attributes=None, enableHash=thrift_spec[2][4],):
    self.attributes = attributes
    self.enableHash = enableHash

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = KeySpec()
            _elem75.read(iprot)
            self.attributes.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.enableHash = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EntityGroupSpec')
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.attributes))
      for iter76 in self.attributes:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.enableHash is not None:
      oprot.writeFieldBegin('enableHash', TType.BOOL, 2)
      oprot.writeBool(self.enableHash)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSchema(object):
  """
  表Schema设置

  Attributes:
   - version: Schema版本号，仅作为输出，作为输入不需要设置
   - entityGroup: Entity group定义, 不设置表示不开启Entity Group支持。
  开启后自动支持应用用户表空间隔离(需配合相应权限设置),
  即每个应用用户将看到独立的表空间
   - primaryIndex: 主键定义
   - secondaryIndexes: 二级索引定义
   - attributes: 属性定义
   - ttl: 记录存活时间，单位为秒。-1表示不会自动删除
   - preSplits: 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'entityGroup', (EntityGroupSpec, EntityGroupSpec.thrift_spec), None, ), # 2
    (3, TType.LIST, 'primaryIndex', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'secondaryIndexes', (TType.STRING,None,TType.STRUCT,(LocalSecondaryIndexSpec, LocalSecondaryIndexSpec.thrift_spec)), None, ), # 4
    (5, TType.MAP, 'attributes', (TType.STRING,None,TType.I32,None), None, ), # 5
    (6, TType.I32, 'ttl', None, -1, ), # 6
    (7, TType.I32, 'preSplits', None, 1, ), # 7
  )

  def __init__(self, version=None, entityGroup=None, primaryIndex=None, secondaryIndexes=None, attributes=None, ttl=thrift_spec[6][4], preSplits=thrift_spec[7][4],):
    self.version = version
    self.entityGroup = entityGroup
    self.primaryIndex = primaryIndex
    self.secondaryIndexes = secondaryIndexes
    self.attributes = attributes
    self.ttl = ttl
    self.preSplits = preSplits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.entityGroup = EntityGroupSpec()
          self.entityGroup.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.primaryIndex = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = KeySpec()
            _elem82.read(iprot)
            self.primaryIndex.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.secondaryIndexes = {}
          (_ktype84, _vtype85, _size83 ) = iprot.readMapBegin()
          for _i87 in xrange(_size83):
            _key88 = iprot.readString();
            _val89 = LocalSecondaryIndexSpec()
            _val89.read(iprot)
            self.secondaryIndexes[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype91, _vtype92, _size90 ) = iprot.readMapBegin()
          for _i94 in xrange(_size90):
            _key95 = iprot.readString();
            _val96 = iprot.readI32();
            self.attributes[_key95] = _val96
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ttl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.preSplits = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSchema')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.entityGroup is not None:
      oprot.writeFieldBegin('entityGroup', TType.STRUCT, 2)
      self.entityGroup.write(oprot)
      oprot.writeFieldEnd()
    if self.primaryIndex is not None:
      oprot.writeFieldBegin('primaryIndex', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryIndex))
      for iter97 in self.primaryIndex:
        iter97.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.secondaryIndexes is not None:
      oprot.writeFieldBegin('secondaryIndexes', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.secondaryIndexes))
      for kiter98,viter99 in self.secondaryIndexes.items():
        oprot.writeString(kiter98)
        viter99.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.attributes))
      for kiter100,viter101 in self.attributes.items():
        oprot.writeString(kiter100)
        oprot.writeI32(viter101)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.I32, 6)
      oprot.writeI32(self.ttl)
      oprot.writeFieldEnd()
    if self.preSplits is not None:
      oprot.writeFieldBegin('preSplits', TType.I32, 7)
      oprot.writeI32(self.preSplits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableMetadata(object):
  """
  表元信息

  Attributes:
   - tableId: 表ID
  仅作为输出值，作为输入时无需指定
   - developerId: 所有者的开发者ID，
  对于CreateTable/AlterTable，值不设置时，默认为当前登录用户。
   - appAcl: 权限控制设置
   - quota: 空间配额
   - throughput: 吞吐量配额
   - description: 表备注信息
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableId', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
    (3, TType.MAP, 'appAcl', (TType.STRING,None,TType.LIST,(TType.I32,None)), None, ), # 3
    (4, TType.STRUCT, 'quota', (TableQuota, TableQuota.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'throughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 5
    (6, TType.STRING, 'description', None, None, ), # 6
  )

  def __init__(self, tableId=None, developerId=None, appAcl=None, quota=None, throughput=None, description=None,):
    self.tableId = tableId
    self.developerId = developerId
    self.appAcl = appAcl
    self.quota = quota
    self.throughput = throughput
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.appAcl = {}
          (_ktype103, _vtype104, _size102 ) = iprot.readMapBegin()
          for _i106 in xrange(_size102):
            _key107 = iprot.readString();
            _val108 = []
            (_etype112, _size109) = iprot.readListBegin()
            for _i113 in xrange(_size109):
              _elem114 = iprot.readI32();
              _val108.append(_elem114)
            iprot.readListEnd()
            self.appAcl[_key107] = _val108
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.quota = TableQuota()
          self.quota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.throughput = ProvisionThroughput()
          self.throughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableMetadata')
    if self.tableId is not None:
      oprot.writeFieldBegin('tableId', TType.STRING, 1)
      oprot.writeString(self.tableId)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    if self.appAcl is not None:
      oprot.writeFieldBegin('appAcl', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.appAcl))
      for kiter115,viter116 in self.appAcl.items():
        oprot.writeString(kiter115)
        oprot.writeListBegin(TType.I32, len(viter116))
        for iter117 in viter116:
          oprot.writeI32(iter117)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.quota is not None:
      oprot.writeFieldBegin('quota', TType.STRUCT, 4)
      self.quota.write(oprot)
      oprot.writeFieldEnd()
    if self.throughput is not None:
      oprot.writeFieldBegin('throughput', TType.STRUCT, 5)
      self.throughput.write(oprot)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 6)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSpec(object):
  """
  表配置信息

  Attributes:
   - schema
   - metadata
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schema', (TableSchema, TableSchema.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (TableMetadata, TableMetadata.thrift_spec), None, ), # 2
  )

  def __init__(self, schema=None, metadata=None,):
    self.schema = schema
    self.metadata = metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schema = TableSchema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = TableMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSpec')
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 1)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatus(object):
  """
  表状态信息

  Attributes:
   - state: 表状态
   - createTime: 创建时间
   - alterTime: 最近修改时间
   - statTime: 最近统计时间
   - size: 占用空间统计，单位为字节
   - rowCount: 行数统计，非即时精确值
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'state', None, None, ), # 1
    (2, TType.I64, 'createTime', None, None, ), # 2
    (3, TType.I64, 'alterTime', None, None, ), # 3
    (4, TType.I64, 'statTime', None, None, ), # 4
    (5, TType.I64, 'size', None, None, ), # 5
    (6, TType.I64, 'rowCount', None, None, ), # 6
  )

  def __init__(self, state=None, createTime=None, alterTime=None, statTime=None, size=None, rowCount=None,):
    self.state = state
    self.createTime = createTime
    self.alterTime = alterTime
    self.statTime = statTime
    self.size = size
    self.rowCount = rowCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.createTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.alterTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.statTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.rowCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatus')
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 1)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I64, 2)
      oprot.writeI64(self.createTime)
      oprot.writeFieldEnd()
    if self.alterTime is not None:
      oprot.writeFieldBegin('alterTime', TType.I64, 3)
      oprot.writeI64(self.alterTime)
      oprot.writeFieldEnd()
    if self.statTime is not None:
      oprot.writeFieldBegin('statTime', TType.I64, 4)
      oprot.writeI64(self.statTime)
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 5)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    if self.rowCount is not None:
      oprot.writeFieldBegin('rowCount', TType.I64, 6)
      oprot.writeI64(self.rowCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableInfo(object):
  """
  表信息

  Attributes:
   - name
   - spec
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'spec', (TableSpec, TableSpec.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'status', (TableStatus, TableStatus.thrift_spec), None, ), # 3
  )

  def __init__(self, name=None, spec=None, status=None,):
    self.name = name
    self.spec = spec
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.spec = TableSpec()
          self.spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.status = TableStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.spec is not None:
      oprot.writeFieldBegin('spec', TType.STRUCT, 2)
      self.spec.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 3)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SimpleCondition(object):
  """
  简单条件，用于checkAndPut/Delete操作，判定逻辑为: value operator field

  Attributes:
   - operator
   - field
   - value
   - rowExist
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'operator', None, None, ), # 1
    (2, TType.STRING, 'field', None, None, ), # 2
    (3, TType.STRUCT, 'value', (Datum, Datum.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'rowExist', None, None, ), # 4
  )

  def __init__(self, operator=None, field=None, value=None, rowExist=None,):
    self.operator = operator
    self.field = field
    self.value = value
    self.rowExist = rowExist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.operator = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.value = Datum()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.rowExist = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SimpleCondition')
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 1)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 2)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 3)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.rowExist is not None:
      oprot.writeFieldBegin('rowExist', TType.BOOL, 4)
      oprot.writeBool(self.rowExist)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSplit(object):
  """
  表分片信息，包括起始和结束的row key

  Attributes:
   - startKey
   - stopKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
  )

  def __init__(self, startKey=None, stopKey=None,):
    self.startKey = startKey
    self.stopKey = stopKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype119, _vtype120, _size118 ) = iprot.readMapBegin()
          for _i122 in xrange(_size118):
            _key123 = iprot.readString();
            _val124 = Datum()
            _val124.read(iprot)
            self.startKey[_key123] = _val124
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype126, _vtype127, _size125 ) = iprot.readMapBegin()
          for _i129 in xrange(_size125):
            _key130 = iprot.readString();
            _val131 = Datum()
            _val131.read(iprot)
            self.stopKey[_key130] = _val131
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSplit')
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter132,viter133 in self.startKey.items():
        oprot.writeString(kiter132)
        viter133.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter134,viter135 in self.stopKey.items():
        oprot.writeString(kiter134)
        viter135.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRequest(object):
  """
  Attributes:
   - tableName
   - keys: 记录主键，必须包含主键所有的属性
   - attributes: 需要返回的属性列表，不指定表示返回所有属性
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, tableName=None, keys=None, attributes=None,):
    self.tableName = tableName
    self.keys = keys
    self.attributes = attributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype137, _vtype138, _size136 ) = iprot.readMapBegin()
          for _i140 in xrange(_size136):
            _key141 = iprot.readString();
            _val142 = Datum()
            _val142.read(iprot)
            self.keys[_key141] = _val142
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype146, _size143) = iprot.readListBegin()
          for _i147 in xrange(_size143):
            _elem148 = iprot.readString();
            self.attributes.append(_elem148)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter149,viter150 in self.keys.items():
        oprot.writeString(kiter149)
        viter150.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter151 in self.attributes:
        oprot.writeString(iter151)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetResult(object):
  """
  Attributes:
   - item
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'item', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
  )

  def __init__(self, item=None,):
    self.item = item

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.item = {}
          (_ktype153, _vtype154, _size152 ) = iprot.readMapBegin()
          for _i156 in xrange(_size152):
            _key157 = iprot.readString();
            _val158 = Datum()
            _val158.read(iprot)
            self.item[_key157] = _val158
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetResult')
    if self.item is not None:
      oprot.writeFieldBegin('item', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.item))
      for kiter159,viter160 in self.item.items():
        oprot.writeString(kiter159)
        viter160.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutRequest(object):
  """
  Attributes:
   - tableName
   - record: 待写入的记录
   - condition: 仅当满足指定条件时执行写入操作
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'condition', (SimpleCondition, SimpleCondition.thrift_spec), None, ), # 3
  )

  def __init__(self, tableName=None, record=None, condition=None,):
    self.tableName = tableName
    self.record = record
    self.condition = condition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype162, _vtype163, _size161 ) = iprot.readMapBegin()
          for _i165 in xrange(_size161):
            _key166 = iprot.readString();
            _val167 = Datum()
            _val167.read(iprot)
            self.record[_key166] = _val167
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.condition = SimpleCondition()
          self.condition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter168,viter169 in self.record.items():
        oprot.writeString(kiter168)
        viter169.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRUCT, 3)
      self.condition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutResult(object):
  """
  Attributes:
   - success: 写入操作是否被执行(是否满足设置的条件)
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncrementRequest(object):
  """
  Attributes:
   - tableName
   - keys: 待自增的记录主键
   - amounts: 需要进行自增操作的属性，必须为整形，且不能为索引属性
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
  )

  def __init__(self, tableName=None, keys=None, amounts=None,):
    self.tableName = tableName
    self.keys = keys
    self.amounts = amounts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype171, _vtype172, _size170 ) = iprot.readMapBegin()
          for _i174 in xrange(_size170):
            _key175 = iprot.readString();
            _val176 = Datum()
            _val176.read(iprot)
            self.keys[_key175] = _val176
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype178, _vtype179, _size177 ) = iprot.readMapBegin()
          for _i181 in xrange(_size177):
            _key182 = iprot.readString();
            _val183 = Datum()
            _val183.read(iprot)
            self.amounts[_key182] = _val183
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncrementRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter184,viter185 in self.keys.items():
        oprot.writeString(kiter184)
        viter185.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter186,viter187 in self.amounts.items():
        oprot.writeString(kiter186)
        viter187.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncrementResult(object):
  """
  Attributes:
   - amounts
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
  )

  def __init__(self, amounts=None,):
    self.amounts = amounts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype189, _vtype190, _size188 ) = iprot.readMapBegin()
          for _i192 in xrange(_size188):
            _key193 = iprot.readString();
            _val194 = Datum()
            _val194.read(iprot)
            self.amounts[_key193] = _val194
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncrementResult')
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter195,viter196 in self.amounts.items():
        oprot.writeString(kiter195)
        viter196.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveRequest(object):
  """
  Attributes:
   - tableName
   - keys: 待删除的记录主键
   - attributes: 待删除的属性列表，不指定表示删除整条记录。
  当删除部分属性时，即使所有属性均已被删除，记录仍存在，删除整条记录需要显式删除
   - condition: 仅当满足指定条件时执行删除操作
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'condition', (SimpleCondition, SimpleCondition.thrift_spec), None, ), # 4
  )

  def __init__(self, tableName=None, keys=None, attributes=None, condition=None,):
    self.tableName = tableName
    self.keys = keys
    self.attributes = attributes
    self.condition = condition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype198, _vtype199, _size197 ) = iprot.readMapBegin()
          for _i201 in xrange(_size197):
            _key202 = iprot.readString();
            _val203 = Datum()
            _val203.read(iprot)
            self.keys[_key202] = _val203
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype207, _size204) = iprot.readListBegin()
          for _i208 in xrange(_size204):
            _elem209 = iprot.readString();
            self.attributes.append(_elem209)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.condition = SimpleCondition()
          self.condition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter210,viter211 in self.keys.items():
        oprot.writeString(kiter210)
        viter211.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter212 in self.attributes:
        oprot.writeString(iter212)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRUCT, 4)
      self.condition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveResult(object):
  """
  Attributes:
   - success: 删除操作是否被执行（是否满足设置的条件）
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Request(object):
  """
  Attributes:
   - getRequest: 随机读操作
   - putRequest: 写入操作，不支持条件
   - incrementRequest: 自增操作
   - removeRequest: 删除操作，不支持条件
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getRequest', (GetRequest, GetRequest.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'putRequest', (PutRequest, PutRequest.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incrementRequest', (IncrementRequest, IncrementRequest.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'removeRequest', (RemoveRequest, RemoveRequest.thrift_spec), None, ), # 4
  )

  def __init__(self, getRequest=None, putRequest=None, incrementRequest=None, removeRequest=None,):
    self.getRequest = getRequest
    self.putRequest = putRequest
    self.incrementRequest = incrementRequest
    self.removeRequest = removeRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getRequest = GetRequest()
          self.getRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.putRequest = PutRequest()
          self.putRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incrementRequest = IncrementRequest()
          self.incrementRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.removeRequest = RemoveRequest()
          self.removeRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Request')
    if self.getRequest is not None:
      oprot.writeFieldBegin('getRequest', TType.STRUCT, 1)
      self.getRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.putRequest is not None:
      oprot.writeFieldBegin('putRequest', TType.STRUCT, 2)
      self.putRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.incrementRequest is not None:
      oprot.writeFieldBegin('incrementRequest', TType.STRUCT, 3)
      self.incrementRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.removeRequest is not None:
      oprot.writeFieldBegin('removeRequest', TType.STRUCT, 4)
      self.removeRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanAction(object):
  """
  Attributes:
   - action: scan时连带操作
   - request: 实际操作，不需要指定key
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, request=None,):
    self.action = action
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanAction')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 2)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanRequest(object):
  """
  范围查询，支持主键和二级索引查询，
  查询范围为闭开区间[startKey, endKey)，
  当指定索引时，查询范围的entity group必须唯一指定

  Attributes:
   - tableName
   - indexName: 不指定表示通过主键进行查询
   - startKey: 查询范围开始，包含startKey，
  如果startKey不是完整键，而是部分key的前缀，则实际查询的startKey为{startKey, 小可能的后缀}补全形式
   - stopKey: 查询范围结束，不包含stopKey，
  如果stopKey不是完整键，而是部分key的前缀，则实际查询的stopKey为{stopKey, 最大可能的后缀}补全形式
   - attributes: 需要返回的属性列表，不指定表示返回所有属性
   - condition: 类SQL WHERE语句的查询条件。
  注意：与SQL不同，此条件仅作为过滤条件，不影响具体查询计划(index, startKey, endKey)，
  进行范围查询时需要显示设置index和startKey以及endKey。每个扫描的记录均计入读配额，
  即使不满足查询条件。尽量避免使用条件过滤，尤其是当过滤掉的记录占一半以上时，强烈不建议使用。
   - limit: 返回记录的最大数目，返回数目可能小于此值(如超出表的读配额时)
   - reverse: 是否进行逆序扫描，进行逆序扫描时startKey应大于endKey，
  注意：逆序查询效率较低，谨慎使用，建议设置对应的Key为逆序存储
   - inGlobalOrder: 是否全局有序扫描
   - cacheResult: 是否将结果放入cache，对于类似MapReduce的大批量扫描的应用应该关闭此选项
   - lookAheadStep: 查找属性在seek之前进行顺序skip的次数。非必要情况，请不要设置
   - action: scan时的连带操作，包括COUNT，DELETE和UPDATE
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'indexName', None, None, ), # 2
    (3, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'condition', None, None, ), # 6
    (7, TType.I32, 'limit', None, 10, ), # 7
    (8, TType.BOOL, 'reverse', None, False, ), # 8
    (9, TType.BOOL, 'inGlobalOrder', None, True, ), # 9
    (10, TType.BOOL, 'cacheResult', None, True, ), # 10
    (11, TType.I32, 'lookAheadStep', None, 0, ), # 11
    (12, TType.STRUCT, 'action', (ScanAction, ScanAction.thrift_spec), None, ), # 12
  )

  def __init__(self, tableName=None, indexName=None, startKey=None, stopKey=None, attributes=None, condition=None, limit=thrift_spec[7][4], reverse=thrift_spec[8][4], inGlobalOrder=thrift_spec[9][4], cacheResult=thrift_spec[10][4], lookAheadStep=thrift_spec[11][4], action=None,):
    self.tableName = tableName
    self.indexName = indexName
    self.startKey = startKey
    self.stopKey = stopKey
    self.attributes = attributes
    self.condition = condition
    self.limit = limit
    self.reverse = reverse
    self.inGlobalOrder = inGlobalOrder
    self.cacheResult = cacheResult
    self.lookAheadStep = lookAheadStep
    self.action = action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.indexName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype214, _vtype215, _size213 ) = iprot.readMapBegin()
          for _i217 in xrange(_size213):
            _key218 = iprot.readString();
            _val219 = Datum()
            _val219.read(iprot)
            self.startKey[_key218] = _val219
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype221, _vtype222, _size220 ) = iprot.readMapBegin()
          for _i224 in xrange(_size220):
            _key225 = iprot.readString();
            _val226 = Datum()
            _val226.read(iprot)
            self.stopKey[_key225] = _val226
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype230, _size227) = iprot.readListBegin()
          for _i231 in xrange(_size227):
            _elem232 = iprot.readString();
            self.attributes.append(_elem232)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.condition = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.reverse = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.inGlobalOrder = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.cacheResult = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.lookAheadStep = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.action = ScanAction()
          self.action.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.indexName is not None:
      oprot.writeFieldBegin('indexName', TType.STRING, 2)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter233,viter234 in self.startKey.items():
        oprot.writeString(kiter233)
        viter234.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter235,viter236 in self.stopKey.items():
        oprot.writeString(kiter235)
        viter236.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter237 in self.attributes:
        oprot.writeString(iter237)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRING, 6)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 7)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.reverse is not None:
      oprot.writeFieldBegin('reverse', TType.BOOL, 8)
      oprot.writeBool(self.reverse)
      oprot.writeFieldEnd()
    if self.inGlobalOrder is not None:
      oprot.writeFieldBegin('inGlobalOrder', TType.BOOL, 9)
      oprot.writeBool(self.inGlobalOrder)
      oprot.writeFieldEnd()
    if self.cacheResult is not None:
      oprot.writeFieldBegin('cacheResult', TType.BOOL, 10)
      oprot.writeBool(self.cacheResult)
      oprot.writeFieldEnd()
    if self.lookAheadStep is not None:
      oprot.writeFieldBegin('lookAheadStep', TType.I32, 11)
      oprot.writeI32(self.lookAheadStep)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.STRUCT, 12)
      self.action.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanResult(object):
  """
  Attributes:
   - nextStartKey: 下一个需要扫描的记录主键，NULL表示达到制定的结束位置
   - records: 扫描的记录
   - throttled: 是否超过表的qps quota
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'nextStartKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'records', (TType.MAP,(TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec))), None, ), # 2
    (3, TType.BOOL, 'throttled', None, None, ), # 3
  )

  def __init__(self, nextStartKey=None, records=None, throttled=None,):
    self.nextStartKey = nextStartKey
    self.records = records
    self.throttled = throttled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.nextStartKey = {}
          (_ktype239, _vtype240, _size238 ) = iprot.readMapBegin()
          for _i242 in xrange(_size238):
            _key243 = iprot.readString();
            _val244 = Datum()
            _val244.read(iprot)
            self.nextStartKey[_key243] = _val244
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype248, _size245) = iprot.readListBegin()
          for _i249 in xrange(_size245):
            _elem250 = {}
            (_ktype252, _vtype253, _size251 ) = iprot.readMapBegin()
            for _i255 in xrange(_size251):
              _key256 = iprot.readString();
              _val257 = Datum()
              _val257.read(iprot)
              _elem250[_key256] = _val257
            iprot.readMapEnd()
            self.records.append(_elem250)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.throttled = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanResult')
    if self.nextStartKey is not None:
      oprot.writeFieldBegin('nextStartKey', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nextStartKey))
      for kiter258,viter259 in self.nextStartKey.items():
        oprot.writeString(kiter258)
        viter259.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.MAP, len(self.records))
      for iter260 in self.records:
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(iter260))
        for kiter261,viter262 in iter260.items():
          oprot.writeString(kiter261)
          viter262.write(oprot)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.throttled is not None:
      oprot.writeFieldBegin('throttled', TType.BOOL, 3)
      oprot.writeBool(self.throttled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchRequestItem(object):
  """
  Attributes:
   - action
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, request=None,):
    self.action = action
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchRequestItem')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 2)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Result(object):
  """
  Attributes:
   - getResult
   - putResult
   - incrementResult
   - removeResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getResult', (GetResult, GetResult.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'putResult', (PutResult, PutResult.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incrementResult', (IncrementResult, IncrementResult.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'removeResult', (RemoveResult, RemoveResult.thrift_spec), None, ), # 4
  )

  def __init__(self, getResult=None, putResult=None, incrementResult=None, removeResult=None,):
    self.getResult = getResult
    self.putResult = putResult
    self.incrementResult = incrementResult
    self.removeResult = removeResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getResult = GetResult()
          self.getResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.putResult = PutResult()
          self.putResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incrementResult = IncrementResult()
          self.incrementResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.removeResult = RemoveResult()
          self.removeResult.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Result')
    if self.getResult is not None:
      oprot.writeFieldBegin('getResult', TType.STRUCT, 1)
      self.getResult.write(oprot)
      oprot.writeFieldEnd()
    if self.putResult is not None:
      oprot.writeFieldBegin('putResult', TType.STRUCT, 2)
      self.putResult.write(oprot)
      oprot.writeFieldEnd()
    if self.incrementResult is not None:
      oprot.writeFieldBegin('incrementResult', TType.STRUCT, 3)
      self.incrementResult.write(oprot)
      oprot.writeFieldEnd()
    if self.removeResult is not None:
      oprot.writeFieldBegin('removeResult', TType.STRUCT, 4)
      self.removeResult.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchResultItem(object):
  """
  Attributes:
   - action: 操作类型
   - success: 是否成功执行，即无异常
   - result: 操作结果，操作成功时被设置
   - serviceException: 操作时发生的异常，操作失败时被设置
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.BOOL, 'success', None, None, ), # 2
    (3, TType.STRUCT, 'result', (Result, Result.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'serviceException', (sds.errors.ttypes.ServiceException, sds.errors.ttypes.ServiceException.thrift_spec), None, ), # 4
  )

  def __init__(self, action=None, success=None, result=None, serviceException=None,):
    self.action = action
    self.success = success
    self.result = result
    self.serviceException = serviceException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result = Result()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.serviceException = sds.errors.ttypes.ServiceException()
          self.serviceException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchResultItem')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 2)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 3)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.serviceException is not None:
      oprot.writeFieldBegin('serviceException', TType.STRUCT, 4)
      self.serviceException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchRequest(object):
  """
  Attributes:
   - items
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'items', (TType.STRUCT,(BatchRequestItem, BatchRequestItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, items=None,):
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype266, _size263) = iprot.readListBegin()
          for _i267 in xrange(_size263):
            _elem268 = BatchRequestItem()
            _elem268.read(iprot)
            self.items.append(_elem268)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchRequest')
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter269 in self.items:
        iter269.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchResult(object):
  """
  Attributes:
   - items
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'items', (TType.STRUCT,(BatchResultItem, BatchResultItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, items=None,):
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype273, _size270) = iprot.readListBegin()
          for _i274 in xrange(_size270):
            _elem275 = BatchResultItem()
            _elem275.read(iprot)
            self.items.append(_elem275)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchResult')
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter276 in self.items:
        iter276.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
