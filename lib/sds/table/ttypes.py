# encoding: utf-8
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import sds.errors.ttypes
import sds.common.ttypes
import sds.auth.ttypes
import rpc.authorization.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class DataType(object):
  """
  数据类型
  """
  BOOL = 1
  INT8 = 2
  INT16 = 3
  INT32 = 4
  INT64 = 5
  FLOAT = 6
  DOUBLE = 7
  STRING = 8
  BINARY = 9
  RAWBINARY = 10
  BOOL_SET = 100
  INT8_SET = 101
  INT16_SET = 102
  INT32_SET = 103
  INT64_SET = 104
  FLOAT_SET = 105
  DOUBLE_SET = 106
  STRING_SET = 107
  BINARY_SET = 108

  _VALUES_TO_NAMES = {
    1: "BOOL",
    2: "INT8",
    3: "INT16",
    4: "INT32",
    5: "INT64",
    6: "FLOAT",
    7: "DOUBLE",
    8: "STRING",
    9: "BINARY",
    10: "RAWBINARY",
    100: "BOOL_SET",
    101: "INT8_SET",
    102: "INT16_SET",
    103: "INT32_SET",
    104: "INT64_SET",
    105: "FLOAT_SET",
    106: "DOUBLE_SET",
    107: "STRING_SET",
    108: "BINARY_SET",
  }

  _NAMES_TO_VALUES = {
    "BOOL": 1,
    "INT8": 2,
    "INT16": 3,
    "INT32": 4,
    "INT64": 5,
    "FLOAT": 6,
    "DOUBLE": 7,
    "STRING": 8,
    "BINARY": 9,
    "RAWBINARY": 10,
    "BOOL_SET": 100,
    "INT8_SET": 101,
    "INT16_SET": 102,
    "INT32_SET": 103,
    "INT64_SET": 104,
    "FLOAT_SET": 105,
    "DOUBLE_SET": 106,
    "STRING_SET": 107,
    "BINARY_SET": 108,
  }

class OperatorType(object):
  """
  操作符类型
  """
  EQUAL = 1
  NOT_EQUAL = 2
  GREATER = 3
  GREATER_OR_EQUAL = 4
  LESS = 5
  LESS_OR_EQUAL = 6

  _VALUES_TO_NAMES = {
    1: "EQUAL",
    2: "NOT_EQUAL",
    3: "GREATER",
    4: "GREATER_OR_EQUAL",
    5: "LESS",
    6: "LESS_OR_EQUAL",
  }

  _NAMES_TO_VALUES = {
    "EQUAL": 1,
    "NOT_EQUAL": 2,
    "GREATER": 3,
    "GREATER_OR_EQUAL": 4,
    "LESS": 5,
    "LESS_OR_EQUAL": 6,
  }

class SecondaryIndexConsistencyMode(object):
  """
  索引数据一致性类型
  """
  LAZY = 0
  EAGER = 1
  IMMUTABLE = 2

  _VALUES_TO_NAMES = {
    0: "LAZY",
    1: "EAGER",
    2: "IMMUTABLE",
  }

  _NAMES_TO_VALUES = {
    "LAZY": 0,
    "EAGER": 1,
    "IMMUTABLE": 2,
  }

class CannedAcl(object):
  """
  ACL模板，针对每个应用进行设置，
  开发者登录可以访问所拥有的表数据，无需额外设置
  """
  APP_SECRET_READ = 1
  APP_SECRET_WRITE = 2
  APP_USER_ENTITY_GROUP_READ = 3
  APP_USER_ENTITY_GROUP_WRITE = 4
  APP_USER_READ = 5
  APP_USER_WRITE = 6
  PUBLIC_READ = 7
  PUBLIC_WRITE = 8

  _VALUES_TO_NAMES = {
    1: "APP_SECRET_READ",
    2: "APP_SECRET_WRITE",
    3: "APP_USER_ENTITY_GROUP_READ",
    4: "APP_USER_ENTITY_GROUP_WRITE",
    5: "APP_USER_READ",
    6: "APP_USER_WRITE",
    7: "PUBLIC_READ",
    8: "PUBLIC_WRITE",
  }

  _NAMES_TO_VALUES = {
    "APP_SECRET_READ": 1,
    "APP_SECRET_WRITE": 2,
    "APP_USER_ENTITY_GROUP_READ": 3,
    "APP_USER_ENTITY_GROUP_WRITE": 4,
    "APP_USER_READ": 5,
    "APP_USER_WRITE": 6,
    "PUBLIC_READ": 7,
    "PUBLIC_WRITE": 8,
  }

class Permission(object):
  READ = 1
  WRITE = 2
  ADMIN = 3

  _VALUES_TO_NAMES = {
    1: "READ",
    2: "WRITE",
    3: "ADMIN",
  }

  _NAMES_TO_VALUES = {
    "READ": 1,
    "WRITE": 2,
    "ADMIN": 3,
  }

class StreamViewType(object):
  """
  stream view type
  """
  RECORD_IMAGE = 1
  MUTATE_LOG = 2

  _VALUES_TO_NAMES = {
    1: "RECORD_IMAGE",
    2: "MUTATE_LOG",
  }

  _NAMES_TO_VALUES = {
    "RECORD_IMAGE": 1,
    "MUTATE_LOG": 2,
  }

class TableState(object):
  """
  表状态
  """
  CREATING = 1
  ENABLING = 2
  ENABLED = 3
  DISABLING = 4
  DISABLED = 5
  DELETING = 6
  DELETED = 7
  LAZY_DELETE = 8
  RENAMING = 9

  _VALUES_TO_NAMES = {
    1: "CREATING",
    2: "ENABLING",
    3: "ENABLED",
    4: "DISABLING",
    5: "DISABLED",
    6: "DELETING",
    7: "DELETED",
    8: "LAZY_DELETE",
    9: "RENAMING",
  }

  _NAMES_TO_VALUES = {
    "CREATING": 1,
    "ENABLING": 2,
    "ENABLED": 3,
    "DISABLING": 4,
    "DISABLED": 5,
    "DELETING": 6,
    "DELETED": 7,
    "LAZY_DELETE": 8,
    "RENAMING": 9,
  }

class SnapshotState(object):
  """
  快照状态
  """
  ENABLED = 1
  INPROGRESS = 2

  _VALUES_TO_NAMES = {
    1: "ENABLED",
    2: "INPROGRESS",
  }

  _NAMES_TO_VALUES = {
    "ENABLED": 1,
    "INPROGRESS": 2,
  }

class ScanOp(object):
  COUNT = 0
  DELETE = 1
  UPDATE = 2

  _VALUES_TO_NAMES = {
    0: "COUNT",
    1: "DELETE",
    2: "UPDATE",
  }

  _NAMES_TO_VALUES = {
    "COUNT": 0,
    "DELETE": 1,
    "UPDATE": 2,
  }

class BatchOp(object):
  GET = 1
  PUT = 2
  INCREMENT = 3
  REMOVE = 4

  _VALUES_TO_NAMES = {
    1: "GET",
    2: "PUT",
    3: "INCREMENT",
    4: "REMOVE",
  }

  _NAMES_TO_VALUES = {
    "GET": 1,
    "PUT": 2,
    "INCREMENT": 3,
    "REMOVE": 4,
  }

class MutationType(object):
  """
  mutation type
  """
  PUT = 1
  DELETE = 2
  INCREMENT = 3

  _VALUES_TO_NAMES = {
    1: "PUT",
    2: "DELETE",
    3: "INCREMENT",
  }

  _NAMES_TO_VALUES = {
    "PUT": 1,
    "DELETE": 2,
    "INCREMENT": 3,
  }


class Value(object):
  """
  数据值union类型

  Attributes:
   - boolValue
   - int8Value
   - int16Value
   - int32Value
   - int64Value
   - doubleValue: 用于FLOAT/DOUBLE类型
   - stringValue
   - binaryValue: 用于BINARY/RAWBINARY类型
   - boolSetValue
   - int8SetValue
   - int16SetValue
   - int32SetValue
   - int64SetValue
   - doubleSetValue: 用于FLOAT/DOUBLE类型集合
   - stringSetValue
   - binarySetValue
   - nullValue: null，只用于RC_BASIC存储格式
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'boolValue', None, None, ), # 1
    (2, TType.BYTE, 'int8Value', None, None, ), # 2
    (3, TType.I16, 'int16Value', None, None, ), # 3
    (4, TType.I32, 'int32Value', None, None, ), # 4
    (5, TType.I64, 'int64Value', None, None, ), # 5
    (6, TType.DOUBLE, 'doubleValue', None, None, ), # 6
    (7, TType.STRING, 'stringValue', None, None, ), # 7
    (8, TType.STRING, 'binaryValue', None, None, ), # 8
    (9, TType.LIST, 'boolSetValue', (TType.BOOL,None), None, ), # 9
    (10, TType.LIST, 'int8SetValue', (TType.BYTE,None), None, ), # 10
    (11, TType.LIST, 'int16SetValue', (TType.I16,None), None, ), # 11
    (12, TType.LIST, 'int32SetValue', (TType.I32,None), None, ), # 12
    (13, TType.LIST, 'int64SetValue', (TType.I64,None), None, ), # 13
    (14, TType.LIST, 'doubleSetValue', (TType.DOUBLE,None), None, ), # 14
    (15, TType.LIST, 'stringSetValue', (TType.STRING,None), None, ), # 15
    (16, TType.LIST, 'binarySetValue', (TType.STRING,None), None, ), # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.BOOL, 'nullValue', None, None, ), # 20
  )

  def __init__(self, boolValue=None, int8Value=None, int16Value=None, int32Value=None, int64Value=None, doubleValue=None, stringValue=None, binaryValue=None, boolSetValue=None, int8SetValue=None, int16SetValue=None, int32SetValue=None, int64SetValue=None, doubleSetValue=None, stringSetValue=None, binarySetValue=None, nullValue=None,):
    self.boolValue = boolValue
    self.int8Value = int8Value
    self.int16Value = int16Value
    self.int32Value = int32Value
    self.int64Value = int64Value
    self.doubleValue = doubleValue
    self.stringValue = stringValue
    self.binaryValue = binaryValue
    self.boolSetValue = boolSetValue
    self.int8SetValue = int8SetValue
    self.int16SetValue = int16SetValue
    self.int32SetValue = int32SetValue
    self.int64SetValue = int64SetValue
    self.doubleSetValue = doubleSetValue
    self.stringSetValue = stringSetValue
    self.binarySetValue = binarySetValue
    self.nullValue = nullValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.boolValue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.int8Value = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.int16Value = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int32Value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.int64Value = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.doubleValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binaryValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.boolSetValue = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readBool();
            self.boolSetValue.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.int8SetValue = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readByte();
            self.int8SetValue.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.int16SetValue = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readI16();
            self.int16SetValue.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.int32SetValue = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = iprot.readI32();
            self.int32SetValue.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.int64SetValue = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = iprot.readI64();
            self.int64SetValue.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.doubleSetValue = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readDouble();
            self.doubleSetValue.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.stringSetValue = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readString();
            self.stringSetValue.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.binarySetValue = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.binarySetValue.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BOOL:
          self.nullValue = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Value')
    if self.boolValue is not None:
      oprot.writeFieldBegin('boolValue', TType.BOOL, 1)
      oprot.writeBool(self.boolValue)
      oprot.writeFieldEnd()
    if self.int8Value is not None:
      oprot.writeFieldBegin('int8Value', TType.BYTE, 2)
      oprot.writeByte(self.int8Value)
      oprot.writeFieldEnd()
    if self.int16Value is not None:
      oprot.writeFieldBegin('int16Value', TType.I16, 3)
      oprot.writeI16(self.int16Value)
      oprot.writeFieldEnd()
    if self.int32Value is not None:
      oprot.writeFieldBegin('int32Value', TType.I32, 4)
      oprot.writeI32(self.int32Value)
      oprot.writeFieldEnd()
    if self.int64Value is not None:
      oprot.writeFieldBegin('int64Value', TType.I64, 5)
      oprot.writeI64(self.int64Value)
      oprot.writeFieldEnd()
    if self.doubleValue is not None:
      oprot.writeFieldBegin('doubleValue', TType.DOUBLE, 6)
      oprot.writeDouble(self.doubleValue)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 7)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.binaryValue is not None:
      oprot.writeFieldBegin('binaryValue', TType.STRING, 8)
      oprot.writeString(self.binaryValue)
      oprot.writeFieldEnd()
    if self.boolSetValue is not None:
      oprot.writeFieldBegin('boolSetValue', TType.LIST, 9)
      oprot.writeListBegin(TType.BOOL, len(self.boolSetValue))
      for iter48 in self.boolSetValue:
        oprot.writeBool(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int8SetValue is not None:
      oprot.writeFieldBegin('int8SetValue', TType.LIST, 10)
      oprot.writeListBegin(TType.BYTE, len(self.int8SetValue))
      for iter49 in self.int8SetValue:
        oprot.writeByte(iter49)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int16SetValue is not None:
      oprot.writeFieldBegin('int16SetValue', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.int16SetValue))
      for iter50 in self.int16SetValue:
        oprot.writeI16(iter50)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int32SetValue is not None:
      oprot.writeFieldBegin('int32SetValue', TType.LIST, 12)
      oprot.writeListBegin(TType.I32, len(self.int32SetValue))
      for iter51 in self.int32SetValue:
        oprot.writeI32(iter51)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int64SetValue is not None:
      oprot.writeFieldBegin('int64SetValue', TType.LIST, 13)
      oprot.writeListBegin(TType.I64, len(self.int64SetValue))
      for iter52 in self.int64SetValue:
        oprot.writeI64(iter52)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.doubleSetValue is not None:
      oprot.writeFieldBegin('doubleSetValue', TType.LIST, 14)
      oprot.writeListBegin(TType.DOUBLE, len(self.doubleSetValue))
      for iter53 in self.doubleSetValue:
        oprot.writeDouble(iter53)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stringSetValue is not None:
      oprot.writeFieldBegin('stringSetValue', TType.LIST, 15)
      oprot.writeListBegin(TType.STRING, len(self.stringSetValue))
      for iter54 in self.stringSetValue:
        oprot.writeString(iter54)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.binarySetValue is not None:
      oprot.writeFieldBegin('binarySetValue', TType.LIST, 16)
      oprot.writeListBegin(TType.STRING, len(self.binarySetValue))
      for iter55 in self.binarySetValue:
        oprot.writeString(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullValue is not None:
      oprot.writeFieldBegin('nullValue', TType.BOOL, 20)
      oprot.writeBool(self.nullValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.boolValue)
    value = (value * 31) ^ hash(self.int8Value)
    value = (value * 31) ^ hash(self.int16Value)
    value = (value * 31) ^ hash(self.int32Value)
    value = (value * 31) ^ hash(self.int64Value)
    value = (value * 31) ^ hash(self.doubleValue)
    value = (value * 31) ^ hash(self.stringValue)
    value = (value * 31) ^ hash(self.binaryValue)
    value = (value * 31) ^ hash(self.boolSetValue)
    value = (value * 31) ^ hash(self.int8SetValue)
    value = (value * 31) ^ hash(self.int16SetValue)
    value = (value * 31) ^ hash(self.int32SetValue)
    value = (value * 31) ^ hash(self.int64SetValue)
    value = (value * 31) ^ hash(self.doubleSetValue)
    value = (value * 31) ^ hash(self.stringSetValue)
    value = (value * 31) ^ hash(self.binarySetValue)
    value = (value * 31) ^ hash(self.nullValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Datum(object):
  """
  数据单元

  Attributes:
   - type
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'value', (Value, Value.thrift_spec), None, ), # 2
  )

  def __init__(self, type=None, value=None,):
    self.type = type
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = Value()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Datum')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvisionThroughput(object):
  """
  吞吐量配额

  Attributes:
   - readCapacity
   - writeCapacity
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'readCapacity', None, None, ), # 1
    (2, TType.I64, 'writeCapacity', None, None, ), # 2
  )

  def __init__(self, readCapacity=None, writeCapacity=None,):
    self.readCapacity = readCapacity
    self.writeCapacity = writeCapacity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.readCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.writeCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvisionThroughput')
    if self.readCapacity is not None:
      oprot.writeFieldBegin('readCapacity', TType.I64, 1)
      oprot.writeI64(self.readCapacity)
      oprot.writeFieldEnd()
    if self.writeCapacity is not None:
      oprot.writeFieldBegin('writeCapacity', TType.I64, 2)
      oprot.writeI64(self.writeCapacity)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.readCapacity)
    value = (value * 31) ^ hash(self.writeCapacity)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableQuota(object):
  """
  空间配额

  Attributes:
   - size: 空间配额，单位为字节
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'size', None, None, ), # 1
  )

  def __init__(self, size=None,):
    self.size = size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.size = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableQuota')
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 1)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.size)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeySpec(object):
  """
  Attributes:
   - attribute
   - asc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'attribute', None, None, ), # 1
    (2, TType.BOOL, 'asc', None, True, ), # 2
  )

  def __init__(self, attribute=None, asc=thrift_spec[2][4],):
    self.attribute = attribute
    self.asc = asc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.attribute = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.asc = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeySpec')
    if self.attribute is not None:
      oprot.writeFieldBegin('attribute', TType.STRING, 1)
      oprot.writeString(self.attribute)
      oprot.writeFieldEnd()
    if self.asc is not None:
      oprot.writeFieldBegin('asc', TType.BOOL, 2)
      oprot.writeBool(self.asc)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.attribute)
    value = (value * 31) ^ hash(self.asc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LocalSecondaryIndexSpec(object):
  """
  局部二级索引定义

  Attributes:
   - indexSchema: 索引定义
   - projections: 映射的属性，仅当索引类型为Eager时才可设置
   - consistencyMode: 索引数据一致性模式
   - unique: 是否为唯一索引
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'indexSchema', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'projections', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'consistencyMode', None,     0, ), # 3
    (4, TType.BOOL, 'unique', None, False, ), # 4
  )

  def __init__(self, indexSchema=None, projections=None, consistencyMode=thrift_spec[3][4], unique=thrift_spec[4][4],):
    self.indexSchema = indexSchema
    self.projections = projections
    self.consistencyMode = consistencyMode
    self.unique = unique

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.indexSchema = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = KeySpec()
            _elem61.read(iprot)
            self.indexSchema.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.projections = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString();
            self.projections.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.consistencyMode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.unique = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LocalSecondaryIndexSpec')
    if self.indexSchema is not None:
      oprot.writeFieldBegin('indexSchema', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.indexSchema))
      for iter68 in self.indexSchema:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.projections is not None:
      oprot.writeFieldBegin('projections', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.projections))
      for iter69 in self.projections:
        oprot.writeString(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.consistencyMode is not None:
      oprot.writeFieldBegin('consistencyMode', TType.I32, 3)
      oprot.writeI32(self.consistencyMode)
      oprot.writeFieldEnd()
    if self.unique is not None:
      oprot.writeFieldBegin('unique', TType.BOOL, 4)
      oprot.writeBool(self.unique)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.indexSchema)
    value = (value * 31) ^ hash(self.projections)
    value = (value * 31) ^ hash(self.consistencyMode)
    value = (value * 31) ^ hash(self.unique)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EntityGroupSpec(object):
  """
  EntityGroup定义

  Attributes:
   - attributes: 属性有序列表
   - enableHash: 是否对属性进行哈希分布:
  开启后表中记录按照(hash(attribute value), attribute value)大小顺序分布
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'attributes', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'enableHash', None, True, ), # 2
  )

  def __init__(self, attributes=None, enableHash=thrift_spec[2][4],):
    self.attributes = attributes
    self.enableHash = enableHash

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = KeySpec()
            _elem75.read(iprot)
            self.attributes.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.enableHash = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EntityGroupSpec')
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.attributes))
      for iter76 in self.attributes:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.enableHash is not None:
      oprot.writeFieldBegin('enableHash', TType.BOOL, 2)
      oprot.writeBool(self.enableHash)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.enableHash)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StreamSpec(object):
  """
  stream specification

  Attributes:
   - enableStream: stream is enable or not
   - viewType: view type
   - attributes: attribute list
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enableStream', None, None, ), # 1
    (2, TType.I32, 'viewType', None, None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, enableStream=None, viewType=None, attributes=None,):
    self.enableStream = enableStream
    self.viewType = viewType
    self.attributes = attributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.enableStream = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.viewType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString();
            self.attributes.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamSpec')
    if self.enableStream is not None:
      oprot.writeFieldBegin('enableStream', TType.BOOL, 1)
      oprot.writeBool(self.enableStream)
      oprot.writeFieldEnd()
    if self.viewType is not None:
      oprot.writeFieldBegin('viewType', TType.I32, 2)
      oprot.writeI32(self.viewType)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter83 in self.attributes:
        oprot.writeString(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.enableStream)
    value = (value * 31) ^ hash(self.viewType)
    value = (value * 31) ^ hash(self.attributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSchema(object):
  """
  表Schema设置

  Attributes:
   - version: Schema版本号，仅作为输出，作为输入不需要设置
   - entityGroup: Entity group定义, 不设置表示不开启Entity Group支持。
  开启后自动支持应用用户表空间隔离(需配合相应权限设置),
  即每个应用用户将看到独立的表空间
   - primaryIndex: 主键定义
   - secondaryIndexes: 二级索引定义
   - attributes: 属性定义
   - ttl: 记录存活时间，单位为秒。-1表示不会自动删除
   - preSplits: 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
   - streams: stream定义, TopicName => StreamSpec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'entityGroup', (EntityGroupSpec, EntityGroupSpec.thrift_spec), None, ), # 2
    (3, TType.LIST, 'primaryIndex', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'secondaryIndexes', (TType.STRING,None,TType.STRUCT,(LocalSecondaryIndexSpec, LocalSecondaryIndexSpec.thrift_spec)), None, ), # 4
    (5, TType.MAP, 'attributes', (TType.STRING,None,TType.I32,None), None, ), # 5
    (6, TType.I32, 'ttl', None, -1, ), # 6
    (7, TType.I32, 'preSplits', None, 1, ), # 7
    (8, TType.MAP, 'streams', (TType.STRING,None,TType.STRUCT,(StreamSpec, StreamSpec.thrift_spec)), None, ), # 8
  )

  def __init__(self, version=None, entityGroup=None, primaryIndex=None, secondaryIndexes=None, attributes=None, ttl=thrift_spec[6][4], preSplits=thrift_spec[7][4], streams=None,):
    self.version = version
    self.entityGroup = entityGroup
    self.primaryIndex = primaryIndex
    self.secondaryIndexes = secondaryIndexes
    self.attributes = attributes
    self.ttl = ttl
    self.preSplits = preSplits
    self.streams = streams

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.entityGroup = EntityGroupSpec()
          self.entityGroup.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.primaryIndex = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = KeySpec()
            _elem89.read(iprot)
            self.primaryIndex.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.secondaryIndexes = {}
          (_ktype91, _vtype92, _size90 ) = iprot.readMapBegin()
          for _i94 in xrange(_size90):
            _key95 = iprot.readString();
            _val96 = LocalSecondaryIndexSpec()
            _val96.read(iprot)
            self.secondaryIndexes[_key95] = _val96
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype98, _vtype99, _size97 ) = iprot.readMapBegin()
          for _i101 in xrange(_size97):
            _key102 = iprot.readString();
            _val103 = iprot.readI32();
            self.attributes[_key102] = _val103
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ttl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.preSplits = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.streams = {}
          (_ktype105, _vtype106, _size104 ) = iprot.readMapBegin()
          for _i108 in xrange(_size104):
            _key109 = iprot.readString();
            _val110 = StreamSpec()
            _val110.read(iprot)
            self.streams[_key109] = _val110
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSchema')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.entityGroup is not None:
      oprot.writeFieldBegin('entityGroup', TType.STRUCT, 2)
      self.entityGroup.write(oprot)
      oprot.writeFieldEnd()
    if self.primaryIndex is not None:
      oprot.writeFieldBegin('primaryIndex', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryIndex))
      for iter111 in self.primaryIndex:
        iter111.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.secondaryIndexes is not None:
      oprot.writeFieldBegin('secondaryIndexes', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.secondaryIndexes))
      for kiter112,viter113 in self.secondaryIndexes.items():
        oprot.writeString(kiter112)
        viter113.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.attributes))
      for kiter114,viter115 in self.attributes.items():
        oprot.writeString(kiter114)
        oprot.writeI32(viter115)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.I32, 6)
      oprot.writeI32(self.ttl)
      oprot.writeFieldEnd()
    if self.preSplits is not None:
      oprot.writeFieldBegin('preSplits', TType.I32, 7)
      oprot.writeI32(self.preSplits)
      oprot.writeFieldEnd()
    if self.streams is not None:
      oprot.writeFieldBegin('streams', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.streams))
      for kiter116,viter117 in self.streams.items():
        oprot.writeString(kiter116)
        viter117.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.entityGroup)
    value = (value * 31) ^ hash(self.primaryIndex)
    value = (value * 31) ^ hash(self.secondaryIndexes)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.ttl)
    value = (value * 31) ^ hash(self.preSplits)
    value = (value * 31) ^ hash(self.streams)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableMetadata(object):
  """
  表元信息

  Attributes:
   - tableId: 表ID
  仅作为输出值，作为输入时无需指定
   - developerId: 所有者的开发者ID，
  对于CreateTable/AlterTable，值不设置时，默认为当前登录用户。
   - appAcl: 权限控制设置
   - quota: @Deprecated 空间配额
   - throughput: 吞吐量配额
   - description: 表备注信息
   - stream: stream设置，deprecated
   - enableSysSnapshot: 是否支持系统定期做snapshot， 默认为true
   - exceededThroughput: 主集群最大超发的读写配额，即系统空闲时可能达到的最大吞吐，设置比throughput大即允许超发
   - slaveThroughput: 预设备集群读写配额
   - exceededSlaveThroughput: 备集群最大超发的读写配额，即系统空闲时可能达到最大的吞吐，设置比slaveThroughput大即允许超发
   - acl: 融合云权限模型的acl
   - spaceId: 表所在的命名空间
   - enableEgAcl: entityGroup acl 开关
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableId', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
    (3, TType.MAP, 'appAcl', (TType.STRING,None,TType.LIST,(TType.I32,None)), None, ), # 3
    (4, TType.STRUCT, 'quota', (TableQuota, TableQuota.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'throughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 5
    (6, TType.STRING, 'description', None, None, ), # 6
    (7, TType.STRUCT, 'stream', (StreamSpec, StreamSpec.thrift_spec), None, ), # 7
    (8, TType.BOOL, 'enableSysSnapshot', None, None, ), # 8
    (9, TType.STRUCT, 'exceededThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'slaveThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'exceededSlaveThroughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 11
    (12, TType.MAP, 'acl', (TType.STRING,None,TType.LIST,(TType.I32,None)), None, ), # 12
    (13, TType.STRING, 'spaceId', None, None, ), # 13
    (14, TType.BOOL, 'enableEgAcl', None, False, ), # 14
  )

  def __init__(self, tableId=None, developerId=None, appAcl=None, quota=None, throughput=None, description=None, stream=None, enableSysSnapshot=None, exceededThroughput=None, slaveThroughput=None, exceededSlaveThroughput=None, acl=None, spaceId=None, enableEgAcl=thrift_spec[14][4],):
    self.tableId = tableId
    self.developerId = developerId
    self.appAcl = appAcl
    self.quota = quota
    self.throughput = throughput
    self.description = description
    self.stream = stream
    self.enableSysSnapshot = enableSysSnapshot
    self.exceededThroughput = exceededThroughput
    self.slaveThroughput = slaveThroughput
    self.exceededSlaveThroughput = exceededSlaveThroughput
    self.acl = acl
    self.spaceId = spaceId
    self.enableEgAcl = enableEgAcl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.appAcl = {}
          (_ktype119, _vtype120, _size118 ) = iprot.readMapBegin()
          for _i122 in xrange(_size118):
            _key123 = iprot.readString();
            _val124 = []
            (_etype128, _size125) = iprot.readListBegin()
            for _i129 in xrange(_size125):
              _elem130 = iprot.readI32();
              _val124.append(_elem130)
            iprot.readListEnd()
            self.appAcl[_key123] = _val124
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.quota = TableQuota()
          self.quota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.throughput = ProvisionThroughput()
          self.throughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.stream = StreamSpec()
          self.stream.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.enableSysSnapshot = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.exceededThroughput = ProvisionThroughput()
          self.exceededThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.slaveThroughput = ProvisionThroughput()
          self.slaveThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.exceededSlaveThroughput = ProvisionThroughput()
          self.exceededSlaveThroughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.MAP:
          self.acl = {}
          (_ktype132, _vtype133, _size131 ) = iprot.readMapBegin()
          for _i135 in xrange(_size131):
            _key136 = iprot.readString();
            _val137 = []
            (_etype141, _size138) = iprot.readListBegin()
            for _i142 in xrange(_size138):
              _elem143 = iprot.readI32();
              _val137.append(_elem143)
            iprot.readListEnd()
            self.acl[_key136] = _val137
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.spaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.enableEgAcl = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableMetadata')
    if self.tableId is not None:
      oprot.writeFieldBegin('tableId', TType.STRING, 1)
      oprot.writeString(self.tableId)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    if self.appAcl is not None:
      oprot.writeFieldBegin('appAcl', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.appAcl))
      for kiter144,viter145 in self.appAcl.items():
        oprot.writeString(kiter144)
        oprot.writeListBegin(TType.I32, len(viter145))
        for iter146 in viter145:
          oprot.writeI32(iter146)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.quota is not None:
      oprot.writeFieldBegin('quota', TType.STRUCT, 4)
      self.quota.write(oprot)
      oprot.writeFieldEnd()
    if self.throughput is not None:
      oprot.writeFieldBegin('throughput', TType.STRUCT, 5)
      self.throughput.write(oprot)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 6)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.stream is not None:
      oprot.writeFieldBegin('stream', TType.STRUCT, 7)
      self.stream.write(oprot)
      oprot.writeFieldEnd()
    if self.enableSysSnapshot is not None:
      oprot.writeFieldBegin('enableSysSnapshot', TType.BOOL, 8)
      oprot.writeBool(self.enableSysSnapshot)
      oprot.writeFieldEnd()
    if self.exceededThroughput is not None:
      oprot.writeFieldBegin('exceededThroughput', TType.STRUCT, 9)
      self.exceededThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.slaveThroughput is not None:
      oprot.writeFieldBegin('slaveThroughput', TType.STRUCT, 10)
      self.slaveThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.exceededSlaveThroughput is not None:
      oprot.writeFieldBegin('exceededSlaveThroughput', TType.STRUCT, 11)
      self.exceededSlaveThroughput.write(oprot)
      oprot.writeFieldEnd()
    if self.acl is not None:
      oprot.writeFieldBegin('acl', TType.MAP, 12)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.acl))
      for kiter147,viter148 in self.acl.items():
        oprot.writeString(kiter147)
        oprot.writeListBegin(TType.I32, len(viter148))
        for iter149 in viter148:
          oprot.writeI32(iter149)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.spaceId is not None:
      oprot.writeFieldBegin('spaceId', TType.STRING, 13)
      oprot.writeString(self.spaceId)
      oprot.writeFieldEnd()
    if self.enableEgAcl is not None:
      oprot.writeFieldBegin('enableEgAcl', TType.BOOL, 14)
      oprot.writeBool(self.enableEgAcl)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableId)
    value = (value * 31) ^ hash(self.developerId)
    value = (value * 31) ^ hash(self.appAcl)
    value = (value * 31) ^ hash(self.quota)
    value = (value * 31) ^ hash(self.throughput)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.stream)
    value = (value * 31) ^ hash(self.enableSysSnapshot)
    value = (value * 31) ^ hash(self.exceededThroughput)
    value = (value * 31) ^ hash(self.slaveThroughput)
    value = (value * 31) ^ hash(self.exceededSlaveThroughput)
    value = (value * 31) ^ hash(self.acl)
    value = (value * 31) ^ hash(self.spaceId)
    value = (value * 31) ^ hash(self.enableEgAcl)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSpec(object):
  """
  表配置信息

  Attributes:
   - schema
   - metadata
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schema', (TableSchema, TableSchema.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (TableMetadata, TableMetadata.thrift_spec), None, ), # 2
  )

  def __init__(self, schema=None, metadata=None,):
    self.schema = schema
    self.metadata = metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schema = TableSchema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = TableMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSpec')
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 1)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schema)
    value = (value * 31) ^ hash(self.metadata)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatus(object):
  """
  表状态信息

  Attributes:
   - state: 表状态
   - createTime: 创建时间
   - alterTime: 最近修改时间
   - statTime: 最近统计时间
   - size: 占用空间统计，单位为字节
   - rowCount: 行数统计，非即时精确值
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'state', None, None, ), # 1
    (2, TType.I64, 'createTime', None, None, ), # 2
    (3, TType.I64, 'alterTime', None, None, ), # 3
    (4, TType.I64, 'statTime', None, None, ), # 4
    (5, TType.I64, 'size', None, None, ), # 5
    (6, TType.I64, 'rowCount', None, None, ), # 6
  )

  def __init__(self, state=None, createTime=None, alterTime=None, statTime=None, size=None, rowCount=None,):
    self.state = state
    self.createTime = createTime
    self.alterTime = alterTime
    self.statTime = statTime
    self.size = size
    self.rowCount = rowCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.createTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.alterTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.statTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.rowCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatus')
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 1)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I64, 2)
      oprot.writeI64(self.createTime)
      oprot.writeFieldEnd()
    if self.alterTime is not None:
      oprot.writeFieldBegin('alterTime', TType.I64, 3)
      oprot.writeI64(self.alterTime)
      oprot.writeFieldEnd()
    if self.statTime is not None:
      oprot.writeFieldBegin('statTime', TType.I64, 4)
      oprot.writeI64(self.statTime)
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 5)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    if self.rowCount is not None:
      oprot.writeFieldBegin('rowCount', TType.I64, 6)
      oprot.writeI64(self.rowCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.alterTime)
    value = (value * 31) ^ hash(self.statTime)
    value = (value * 31) ^ hash(self.size)
    value = (value * 31) ^ hash(self.rowCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableInfo(object):
  """
  表信息

  Attributes:
   - name
   - spec
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'spec', (TableSpec, TableSpec.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'status', (TableStatus, TableStatus.thrift_spec), None, ), # 3
  )

  def __init__(self, name=None, spec=None, status=None,):
    self.name = name
    self.spec = spec
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.spec = TableSpec()
          self.spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.status = TableStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.spec is not None:
      oprot.writeFieldBegin('spec', TType.STRUCT, 2)
      self.spec.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 3)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.spec)
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SimpleCondition(object):
  """
  简单条件，用于checkAndPut/Delete操作，判定逻辑为: value operator field

  Attributes:
   - operator
   - field
   - value
   - rowExist
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'operator', None, None, ), # 1
    (2, TType.STRING, 'field', None, None, ), # 2
    (3, TType.STRUCT, 'value', (Datum, Datum.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'rowExist', None, None, ), # 4
  )

  def __init__(self, operator=None, field=None, value=None, rowExist=None,):
    self.operator = operator
    self.field = field
    self.value = value
    self.rowExist = rowExist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.operator = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.value = Datum()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.rowExist = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SimpleCondition')
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 1)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 2)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 3)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.rowExist is not None:
      oprot.writeFieldBegin('rowExist', TType.BOOL, 4)
      oprot.writeBool(self.rowExist)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.rowExist)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSplit(object):
  """
  表分片信息，包括起始和结束的row key

  Attributes:
   - startKey
   - stopKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
  )

  def __init__(self, startKey=None, stopKey=None,):
    self.startKey = startKey
    self.stopKey = stopKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype151, _vtype152, _size150 ) = iprot.readMapBegin()
          for _i154 in xrange(_size150):
            _key155 = iprot.readString();
            _val156 = Datum()
            _val156.read(iprot)
            self.startKey[_key155] = _val156
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype158, _vtype159, _size157 ) = iprot.readMapBegin()
          for _i161 in xrange(_size157):
            _key162 = iprot.readString();
            _val163 = Datum()
            _val163.read(iprot)
            self.stopKey[_key162] = _val163
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSplit')
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter164,viter165 in self.startKey.items():
        oprot.writeString(kiter164)
        viter165.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter166,viter167 in self.stopKey.items():
        oprot.writeString(kiter166)
        viter167.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startKey)
    value = (value * 31) ^ hash(self.stopKey)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRequest(object):
  """
  Attributes:
   - tableName
   - keys: 记录主键，必须包含主键所有的属性
   - attributes: 需要返回的属性列表，不指定表示返回所有属性
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, tableName=None, keys=None, attributes=None,):
    self.tableName = tableName
    self.keys = keys
    self.attributes = attributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype169, _vtype170, _size168 ) = iprot.readMapBegin()
          for _i172 in xrange(_size168):
            _key173 = iprot.readString();
            _val174 = Datum()
            _val174.read(iprot)
            self.keys[_key173] = _val174
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype178, _size175) = iprot.readListBegin()
          for _i179 in xrange(_size175):
            _elem180 = iprot.readString();
            self.attributes.append(_elem180)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter181,viter182 in self.keys.items():
        oprot.writeString(kiter181)
        viter182.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter183 in self.attributes:
        oprot.writeString(iter183)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.attributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetResult(object):
  """
  Attributes:
   - item
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'item', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
  )

  def __init__(self, item=None,):
    self.item = item

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.item = {}
          (_ktype185, _vtype186, _size184 ) = iprot.readMapBegin()
          for _i188 in xrange(_size184):
            _key189 = iprot.readString();
            _val190 = Datum()
            _val190.read(iprot)
            self.item[_key189] = _val190
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetResult')
    if self.item is not None:
      oprot.writeFieldBegin('item', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.item))
      for kiter191,viter192 in self.item.items():
        oprot.writeString(kiter191)
        viter192.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.item)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutRequest(object):
  """
  Attributes:
   - tableName
   - record: 待写入的记录
   - condition: 仅当满足指定条件时执行写入操作
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'condition', (SimpleCondition, SimpleCondition.thrift_spec), None, ), # 3
  )

  def __init__(self, tableName=None, record=None, condition=None,):
    self.tableName = tableName
    self.record = record
    self.condition = condition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype194, _vtype195, _size193 ) = iprot.readMapBegin()
          for _i197 in xrange(_size193):
            _key198 = iprot.readString();
            _val199 = Datum()
            _val199.read(iprot)
            self.record[_key198] = _val199
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.condition = SimpleCondition()
          self.condition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter200,viter201 in self.record.items():
        oprot.writeString(kiter200)
        viter201.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRUCT, 3)
      self.condition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.condition)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutResult(object):
  """
  Attributes:
   - success: 写入操作是否被执行(是否满足设置的条件)
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncrementRequest(object):
  """
  Attributes:
   - tableName
   - keys: 待自增的记录主键
   - amounts: 需要进行自增操作的属性，必须为整形，且不能为索引属性
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
  )

  def __init__(self, tableName=None, keys=None, amounts=None,):
    self.tableName = tableName
    self.keys = keys
    self.amounts = amounts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype203, _vtype204, _size202 ) = iprot.readMapBegin()
          for _i206 in xrange(_size202):
            _key207 = iprot.readString();
            _val208 = Datum()
            _val208.read(iprot)
            self.keys[_key207] = _val208
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype210, _vtype211, _size209 ) = iprot.readMapBegin()
          for _i213 in xrange(_size209):
            _key214 = iprot.readString();
            _val215 = Datum()
            _val215.read(iprot)
            self.amounts[_key214] = _val215
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncrementRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter216,viter217 in self.keys.items():
        oprot.writeString(kiter216)
        viter217.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter218,viter219 in self.amounts.items():
        oprot.writeString(kiter218)
        viter219.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.amounts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncrementResult(object):
  """
  Attributes:
   - amounts
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
  )

  def __init__(self, amounts=None,):
    self.amounts = amounts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype221, _vtype222, _size220 ) = iprot.readMapBegin()
          for _i224 in xrange(_size220):
            _key225 = iprot.readString();
            _val226 = Datum()
            _val226.read(iprot)
            self.amounts[_key225] = _val226
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncrementResult')
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter227,viter228 in self.amounts.items():
        oprot.writeString(kiter227)
        viter228.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.amounts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveRequest(object):
  """
  Attributes:
   - tableName
   - keys: 待删除的记录主键
   - attributes: 待删除的属性列表，不指定表示删除整条记录。
  当删除部分属性时，即使所有属性均已被删除，记录仍存在，删除整条记录需要显式删除
   - condition: 仅当满足指定条件时执行删除操作
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'condition', (SimpleCondition, SimpleCondition.thrift_spec), None, ), # 4
  )

  def __init__(self, tableName=None, keys=None, attributes=None, condition=None,):
    self.tableName = tableName
    self.keys = keys
    self.attributes = attributes
    self.condition = condition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype230, _vtype231, _size229 ) = iprot.readMapBegin()
          for _i233 in xrange(_size229):
            _key234 = iprot.readString();
            _val235 = Datum()
            _val235.read(iprot)
            self.keys[_key234] = _val235
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype239, _size236) = iprot.readListBegin()
          for _i240 in xrange(_size236):
            _elem241 = iprot.readString();
            self.attributes.append(_elem241)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.condition = SimpleCondition()
          self.condition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter242,viter243 in self.keys.items():
        oprot.writeString(kiter242)
        viter243.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter244 in self.attributes:
        oprot.writeString(iter244)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRUCT, 4)
      self.condition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.condition)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveResult(object):
  """
  Attributes:
   - success: 删除操作是否被执行（是否满足设置的条件）
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Request(object):
  """
  Attributes:
   - getRequest: 随机读操作
   - putRequest: 写入操作，不支持条件
   - incrementRequest: 自增操作
   - removeRequest: 删除操作，不支持条件
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getRequest', (GetRequest, GetRequest.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'putRequest', (PutRequest, PutRequest.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incrementRequest', (IncrementRequest, IncrementRequest.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'removeRequest', (RemoveRequest, RemoveRequest.thrift_spec), None, ), # 4
  )

  def __init__(self, getRequest=None, putRequest=None, incrementRequest=None, removeRequest=None,):
    self.getRequest = getRequest
    self.putRequest = putRequest
    self.incrementRequest = incrementRequest
    self.removeRequest = removeRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getRequest = GetRequest()
          self.getRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.putRequest = PutRequest()
          self.putRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incrementRequest = IncrementRequest()
          self.incrementRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.removeRequest = RemoveRequest()
          self.removeRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Request')
    if self.getRequest is not None:
      oprot.writeFieldBegin('getRequest', TType.STRUCT, 1)
      self.getRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.putRequest is not None:
      oprot.writeFieldBegin('putRequest', TType.STRUCT, 2)
      self.putRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.incrementRequest is not None:
      oprot.writeFieldBegin('incrementRequest', TType.STRUCT, 3)
      self.incrementRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.removeRequest is not None:
      oprot.writeFieldBegin('removeRequest', TType.STRUCT, 4)
      self.removeRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.getRequest)
    value = (value * 31) ^ hash(self.putRequest)
    value = (value * 31) ^ hash(self.incrementRequest)
    value = (value * 31) ^ hash(self.removeRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanAction(object):
  """
  Attributes:
   - action: scan时连带操作
   - request: 实际操作，不需要指定key
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, request=None,):
    self.action = action
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanAction')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 2)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanRequest(object):
  """
  范围查询，支持主键和二级索引查询，
  查询范围为闭开区间[startKey, endKey)，
  当指定索引时，查询范围的entity group必须唯一指定

  Attributes:
   - tableName
   - indexName: 不指定表示通过主键进行查询
   - startKey: 查询范围开始，包含startKey，
  如果startKey不是完整键，而是部分key的前缀，则实际查询的startKey为{startKey, 最小可能的后缀}补全形式
   - stopKey: 查询范围结束，不包含stopKey，
  如果stopKey不是完整键，而是部分key的前缀，则实际查询的stopKey为{stopKey, 最大可能的后缀}补全形式
   - attributes: 需要返回的属性列表，不指定表示返回所有属性
   - condition: 类SQL WHERE语句的查询条件。
  注意：与SQL不同，此条件仅作为过滤条件，不影响具体查询计划(index, startKey, endKey)，
  进行范围查询时需要显示设置index和startKey以及endKey。每个扫描的记录均计入读配额，
  即使不满足查询条件。尽量避免使用条件过滤，尤其是当过滤掉的记录占一半以上时，强烈不建议使用。
   - limit: 返回记录的最大数目，返回数目可能小于此值(如超出表的读配额时)
   - reverse: 是否进行逆序扫描，进行逆序扫描时startKey应大于endKey，
  注意：逆序查询效率较低，谨慎使用，建议设置对应的Key为逆序存储
   - inGlobalOrder: 是否全局有序扫描
   - cacheResult: 是否将结果放入cache，对于类似MapReduce的大批量扫描的应用应该关闭此选项
   - lookAheadStep: 查找属性在seek之前进行顺序skip的次数。非必要情况，请不要设置
   - action: scan时的连带操作，包括COUNT，DELETE和UPDATE
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'indexName', None, None, ), # 2
    (3, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'condition', None, None, ), # 6
    (7, TType.I32, 'limit', None, 10, ), # 7
    (8, TType.BOOL, 'reverse', None, False, ), # 8
    (9, TType.BOOL, 'inGlobalOrder', None, True, ), # 9
    (10, TType.BOOL, 'cacheResult', None, True, ), # 10
    (11, TType.I32, 'lookAheadStep', None, 0, ), # 11
    (12, TType.STRUCT, 'action', (ScanAction, ScanAction.thrift_spec), None, ), # 12
  )

  def __init__(self, tableName=None, indexName=None, startKey=None, stopKey=None, attributes=None, condition=None, limit=thrift_spec[7][4], reverse=thrift_spec[8][4], inGlobalOrder=thrift_spec[9][4], cacheResult=thrift_spec[10][4], lookAheadStep=thrift_spec[11][4], action=None,):
    self.tableName = tableName
    self.indexName = indexName
    self.startKey = startKey
    self.stopKey = stopKey
    self.attributes = attributes
    self.condition = condition
    self.limit = limit
    self.reverse = reverse
    self.inGlobalOrder = inGlobalOrder
    self.cacheResult = cacheResult
    self.lookAheadStep = lookAheadStep
    self.action = action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.indexName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype246, _vtype247, _size245 ) = iprot.readMapBegin()
          for _i249 in xrange(_size245):
            _key250 = iprot.readString();
            _val251 = Datum()
            _val251.read(iprot)
            self.startKey[_key250] = _val251
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype253, _vtype254, _size252 ) = iprot.readMapBegin()
          for _i256 in xrange(_size252):
            _key257 = iprot.readString();
            _val258 = Datum()
            _val258.read(iprot)
            self.stopKey[_key257] = _val258
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype262, _size259) = iprot.readListBegin()
          for _i263 in xrange(_size259):
            _elem264 = iprot.readString();
            self.attributes.append(_elem264)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.condition = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.reverse = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.inGlobalOrder = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.cacheResult = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.lookAheadStep = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.action = ScanAction()
          self.action.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.indexName is not None:
      oprot.writeFieldBegin('indexName', TType.STRING, 2)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter265,viter266 in self.startKey.items():
        oprot.writeString(kiter265)
        viter266.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter267,viter268 in self.stopKey.items():
        oprot.writeString(kiter267)
        viter268.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter269 in self.attributes:
        oprot.writeString(iter269)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRING, 6)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 7)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.reverse is not None:
      oprot.writeFieldBegin('reverse', TType.BOOL, 8)
      oprot.writeBool(self.reverse)
      oprot.writeFieldEnd()
    if self.inGlobalOrder is not None:
      oprot.writeFieldBegin('inGlobalOrder', TType.BOOL, 9)
      oprot.writeBool(self.inGlobalOrder)
      oprot.writeFieldEnd()
    if self.cacheResult is not None:
      oprot.writeFieldBegin('cacheResult', TType.BOOL, 10)
      oprot.writeBool(self.cacheResult)
      oprot.writeFieldEnd()
    if self.lookAheadStep is not None:
      oprot.writeFieldBegin('lookAheadStep', TType.I32, 11)
      oprot.writeI32(self.lookAheadStep)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.STRUCT, 12)
      self.action.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.indexName)
    value = (value * 31) ^ hash(self.startKey)
    value = (value * 31) ^ hash(self.stopKey)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.condition)
    value = (value * 31) ^ hash(self.limit)
    value = (value * 31) ^ hash(self.reverse)
    value = (value * 31) ^ hash(self.inGlobalOrder)
    value = (value * 31) ^ hash(self.cacheResult)
    value = (value * 31) ^ hash(self.lookAheadStep)
    value = (value * 31) ^ hash(self.action)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanResult(object):
  """
  Attributes:
   - nextStartKey: 下一个需要扫描的记录主键，NULL表示达到制定的结束位置
   - records: 扫描的记录
   - throttled: 是否超过表的qps quota
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'nextStartKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'records', (TType.MAP,(TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec))), None, ), # 2
    (3, TType.BOOL, 'throttled', None, None, ), # 3
  )

  def __init__(self, nextStartKey=None, records=None, throttled=None,):
    self.nextStartKey = nextStartKey
    self.records = records
    self.throttled = throttled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.nextStartKey = {}
          (_ktype271, _vtype272, _size270 ) = iprot.readMapBegin()
          for _i274 in xrange(_size270):
            _key275 = iprot.readString();
            _val276 = Datum()
            _val276.read(iprot)
            self.nextStartKey[_key275] = _val276
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype280, _size277) = iprot.readListBegin()
          for _i281 in xrange(_size277):
            _elem282 = {}
            (_ktype284, _vtype285, _size283 ) = iprot.readMapBegin()
            for _i287 in xrange(_size283):
              _key288 = iprot.readString();
              _val289 = Datum()
              _val289.read(iprot)
              _elem282[_key288] = _val289
            iprot.readMapEnd()
            self.records.append(_elem282)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.throttled = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanResult')
    if self.nextStartKey is not None:
      oprot.writeFieldBegin('nextStartKey', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nextStartKey))
      for kiter290,viter291 in self.nextStartKey.items():
        oprot.writeString(kiter290)
        viter291.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.MAP, len(self.records))
      for iter292 in self.records:
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(iter292))
        for kiter293,viter294 in iter292.items():
          oprot.writeString(kiter293)
          viter294.write(oprot)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.throttled is not None:
      oprot.writeFieldBegin('throttled', TType.BOOL, 3)
      oprot.writeBool(self.throttled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.nextStartKey)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.throttled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchRequestItem(object):
  """
  Attributes:
   - action
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, request=None,):
    self.action = action
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchRequestItem')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 2)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Result(object):
  """
  Attributes:
   - getResult
   - putResult
   - incrementResult
   - removeResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getResult', (GetResult, GetResult.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'putResult', (PutResult, PutResult.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incrementResult', (IncrementResult, IncrementResult.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'removeResult', (RemoveResult, RemoveResult.thrift_spec), None, ), # 4
  )

  def __init__(self, getResult=None, putResult=None, incrementResult=None, removeResult=None,):
    self.getResult = getResult
    self.putResult = putResult
    self.incrementResult = incrementResult
    self.removeResult = removeResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getResult = GetResult()
          self.getResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.putResult = PutResult()
          self.putResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incrementResult = IncrementResult()
          self.incrementResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.removeResult = RemoveResult()
          self.removeResult.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Result')
    if self.getResult is not None:
      oprot.writeFieldBegin('getResult', TType.STRUCT, 1)
      self.getResult.write(oprot)
      oprot.writeFieldEnd()
    if self.putResult is not None:
      oprot.writeFieldBegin('putResult', TType.STRUCT, 2)
      self.putResult.write(oprot)
      oprot.writeFieldEnd()
    if self.incrementResult is not None:
      oprot.writeFieldBegin('incrementResult', TType.STRUCT, 3)
      self.incrementResult.write(oprot)
      oprot.writeFieldEnd()
    if self.removeResult is not None:
      oprot.writeFieldBegin('removeResult', TType.STRUCT, 4)
      self.removeResult.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.getResult)
    value = (value * 31) ^ hash(self.putResult)
    value = (value * 31) ^ hash(self.incrementResult)
    value = (value * 31) ^ hash(self.removeResult)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchResultItem(object):
  """
  Attributes:
   - action: 操作类型
   - success: 是否成功执行，即无异常
   - result: 操作结果，操作成功时被设置
   - serviceException: 操作时发生的异常，操作失败时被设置
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.BOOL, 'success', None, None, ), # 2
    (3, TType.STRUCT, 'result', (Result, Result.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'serviceException', (sds.errors.ttypes.ServiceException, sds.errors.ttypes.ServiceException.thrift_spec), None, ), # 4
  )

  def __init__(self, action=None, success=None, result=None, serviceException=None,):
    self.action = action
    self.success = success
    self.result = result
    self.serviceException = serviceException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result = Result()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.serviceException = sds.errors.ttypes.ServiceException()
          self.serviceException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchResultItem')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 2)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 3)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.serviceException is not None:
      oprot.writeFieldBegin('serviceException', TType.STRUCT, 4)
      self.serviceException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.result)
    value = (value * 31) ^ hash(self.serviceException)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchRequest(object):
  """
  Attributes:
   - items
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'items', (TType.STRUCT,(BatchRequestItem, BatchRequestItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, items=None,):
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype298, _size295) = iprot.readListBegin()
          for _i299 in xrange(_size295):
            _elem300 = BatchRequestItem()
            _elem300.read(iprot)
            self.items.append(_elem300)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchRequest')
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter301 in self.items:
        iter301.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.items)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchResult(object):
  """
  Attributes:
   - items
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'items', (TType.STRUCT,(BatchResultItem, BatchResultItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, items=None,):
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype305, _size302) = iprot.readListBegin()
          for _i306 in xrange(_size302):
            _elem307 = BatchResultItem()
            _elem307.read(iprot)
            self.items.append(_elem307)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchResult')
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter308 in self.items:
        iter308.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.items)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InternalMutationLogEntry(object):
  """
  internal mutation log entry


  Attributes:
   - record: row key and items
   - type: mutation type
   - rowDeleted: is row deleted or not
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'record', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.BOOL, 'rowDeleted', None, None, ), # 3
  )

  def __init__(self, record=None, type=None, rowDeleted=None,):
    self.record = record
    self.type = type
    self.rowDeleted = rowDeleted

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype310, _vtype311, _size309 ) = iprot.readMapBegin()
          for _i313 in xrange(_size309):
            _key314 = iprot.readString();
            _val315 = iprot.readString();
            self.record[_key314] = _val315
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.rowDeleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InternalMutationLogEntry')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.record))
      for kiter316,viter317 in self.record.items():
        oprot.writeString(kiter316)
        oprot.writeString(viter317)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.rowDeleted is not None:
      oprot.writeFieldBegin('rowDeleted', TType.BOOL, 3)
      oprot.writeBool(self.rowDeleted)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.rowDeleted)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MutationLogEntry(object):
  """
  mutation log entry


  Attributes:
   - record: row key and items
   - type: mutation type
   - rowDeleted: is row deleted or not
   - timestamp: mutation timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.BOOL, 'rowDeleted', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
  )

  def __init__(self, record=None, type=None, rowDeleted=None, timestamp=None,):
    self.record = record
    self.type = type
    self.rowDeleted = rowDeleted
    self.timestamp = timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype319, _vtype320, _size318 ) = iprot.readMapBegin()
          for _i322 in xrange(_size318):
            _key323 = iprot.readString();
            _val324 = Datum()
            _val324.read(iprot)
            self.record[_key323] = _val324
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.rowDeleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MutationLogEntry')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter325,viter326 in self.record.items():
        oprot.writeString(kiter325)
        viter326.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.rowDeleted is not None:
      oprot.writeFieldBegin('rowDeleted', TType.BOOL, 3)
      oprot.writeBool(self.rowDeleted)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.rowDeleted)
    value = (value * 31) ^ hash(self.timestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordImage(object):
  """
  record image


  Attributes:
   - record: row key and attributes
   - rowDeleted: is row deleted or not
   - timestamp: record mutated timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'rowDeleted', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
  )

  def __init__(self, record=None, rowDeleted=None, timestamp=None,):
    self.record = record
    self.rowDeleted = rowDeleted
    self.timestamp = timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype328, _vtype329, _size327 ) = iprot.readMapBegin()
          for _i331 in xrange(_size327):
            _key332 = iprot.readString();
            _val333 = Datum()
            _val333.read(iprot)
            self.record[_key332] = _val333
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.rowDeleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordImage')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter334,viter335 in self.record.items():
        oprot.writeString(kiter334)
        viter335.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.rowDeleted is not None:
      oprot.writeFieldBegin('rowDeleted', TType.BOOL, 2)
      oprot.writeBool(self.rowDeleted)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.rowDeleted)
    value = (value * 31) ^ hash(self.timestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
